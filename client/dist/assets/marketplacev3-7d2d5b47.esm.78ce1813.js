import{v,w,x as u,y as I,z as C,F as M,H as O,I as B,C as _,_ as i,a as j,M as H,b as K,h as W,G as b,f as k,i as Z,k as T,J as L,K as U,B as s,O as A,Q as y,U as g,V as E,W as N,s as l,X as p,Y as m,Z as F,$ as J,a0 as S,a1 as Q,a2 as X,a3 as Y,a4 as tt,a5 as rt,a6 as z,A as V,a7 as et,a8 as at,a9 as P,aa as G,t as q,N as x,ab as nt}from"./index.7d96b767.js";const D=v.object({assetContractAddress:w,tokenId:u,quantity:u.default(1),currencyContractAddress:w.default(I),pricePerToken:C,startTimestamp:M.default(new Date),endTimestamp:O,isReservedListing:v.boolean().default(!1)});class st{constructor(t,r){i(this,"featureName",U.name),i(this,"contractWrapper",void 0),i(this,"storage",void 0),i(this,"events",void 0),i(this,"interceptor",void 0),i(this,"encoder",void 0),i(this,"estimator",void 0),this.contractWrapper=t,this.storage=r,this.events=new k(this.contractWrapper),this.encoder=new W(this.contractWrapper),this.interceptor=new T(this.contractWrapper),this.estimator=new b(this.contractWrapper)}getAddress(){return this.contractWrapper.readContract.address}async getTotalCount(){return await this.contractWrapper.readContract.totalListings()}async getAll(t){const r=await this.getTotalCount();let e=s.from((t==null?void 0:t.start)||0).toNumber(),a=r.toNumber();if(a===0)throw new Error("No listings exist on the contract.");let n=[];n=(await A(e,a,this.contractWrapper.readContract.getAllListings)).flat();const o=this.applyFilter(n,t);return await Promise.all(o.map(d=>this.mapListing(d)))}async getAllValid(t){const r=await this.getTotalCount();let e=s.from((t==null?void 0:t.start)||0).toNumber(),a=r.toNumber();if(a===0)throw new Error("No listings exist on the contract.");let n=[];n=(await A(e,a,this.contractWrapper.readContract.getAllValidListings)).flat();const o=this.applyFilter(n,t);return await Promise.all(o.map(d=>this.mapListing(d)))}async getListing(t){const r=await this.contractWrapper.readContract.getListing(t);return await this.mapListing(r)}async isBuyerApprovedForListing(t,r){if(!(await this.validateListing(s.from(t))).isReservedListing)throw new Error(`Listing ${t} is not a reserved listing.`);return await this.contractWrapper.readContract.isBuyerApprovedForListing(t,r)}async isCurrencyApprovedForListing(t,r){return await this.validateListing(s.from(t)),await this.contractWrapper.readContract.isCurrencyApprovedForListing(t,r)}async currencyPriceForListing(t,r){const e=await this.validateListing(s.from(t));if(r===e.currencyContractAddress)return e.pricePerToken;if(!await this.isCurrencyApprovedForListing(t,r))throw new Error(`Currency ${r} is not approved for Listing ${t}.`);return await this.contractWrapper.readContract.currencyPriceForListing(t,r)}async createListing(t){const r=D.parse(t);await y(this.contractWrapper,this.getAddress(),r.assetContractAddress,r.tokenId,await this.contractWrapper.getSignerAddress());const e=await g(this.contractWrapper.getProvider(),r.pricePerToken,r.currencyContractAddress),n=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;r.startTimestamp.lt(n)&&(r.startTimestamp=s.from(n));const c=await this.contractWrapper.sendTransaction("createListing",[{assetContract:r.assetContractAddress,tokenId:r.tokenId,quantity:r.quantity,currency:E(r.currencyContractAddress),pricePerToken:e,startTimestamp:r.startTimestamp,endTimestamp:r.endTimestamp,reserved:r.isReservedListing}],{gasLimit:5e5});return{id:this.contractWrapper.parseLogs("NewListing",c==null?void 0:c.logs)[0].args.listingId,receipt:c}}async updateListing(t,r){const e=D.parse(r);await y(this.contractWrapper,this.getAddress(),e.assetContractAddress,e.tokenId,await this.contractWrapper.getSignerAddress());const a=await g(this.contractWrapper.getProvider(),e.pricePerToken,e.currencyContractAddress),n=await this.contractWrapper.sendTransaction("updateListing",[t,{assetContract:e.assetContractAddress,tokenId:e.tokenId,quantity:e.quantity,currency:E(e.currencyContractAddress),pricePerToken:a,startTimestamp:e.startTimestamp,endTimestamp:e.endTimestamp,reserved:e.isReservedListing}],{gasLimit:5e5});return{id:this.contractWrapper.parseLogs("UpdatedListing",n==null?void 0:n.logs)[0].args.listingId,receipt:n}}async cancelListing(t){return{receipt:await this.contractWrapper.sendTransaction("cancelListing",[t])}}async buyFromListing(t,r,e){const a=await this.validateListing(s.from(t)),{valid:n,error:c}=await this.isStillValidListing(a,r);if(!n)throw new Error(`Listing ${t} is no longer valid. ${c}`);const o=e||await this.contractWrapper.getSignerAddress(),d=s.from(r),h=s.from(a.pricePerToken).mul(d),f=await this.contractWrapper.getCallOverrides()||{};return await N(this.contractWrapper,h,a.currencyContractAddress,f),{receipt:await this.contractWrapper.sendTransaction("buyFromListing",[t,o,d,a.currencyContractAddress,h],f)}}async approveBuyerForReservedListing(t,r){if(await this.isBuyerApprovedForListing(t,r))throw new Error(`Buyer ${r} already approved for listing ${t}.`);return{receipt:await this.contractWrapper.sendTransaction("approveBuyerForListing",[t,r,!0])}}async revokeBuyerApprovalForReservedListing(t,r){if(await this.isBuyerApprovedForListing(t,r))return{receipt:await this.contractWrapper.sendTransaction("approveBuyerForListing",[t,r,!1])};throw new Error(`Buyer ${r} not approved for listing ${t}.`)}async approveCurrencyForListing(t,r,e){const a=await this.validateListing(s.from(t));r===a.currencyContractAddress&&l(e===a.pricePerToken,"Approving listing currency with a different price.");const n=await this.contractWrapper.readContract.currencyPriceForListing(t,r);return l(e===n,"Currency already approved with this price."),{receipt:await this.contractWrapper.sendTransaction("approveCurrencyForListing",[t,r,e])}}async revokeCurrencyApprovalForListing(t,r){const e=await this.validateListing(s.from(t));if(r===e.currencyContractAddress)throw new Error("Can't revoke approval for main listing currency.");const a=await this.contractWrapper.readContract.currencyPriceForListing(t,r);return l(!a.isZero(),"Currency not approved."),{receipt:await this.contractWrapper.sendTransaction("approveCurrencyForListing",[t,r,s.from(0)])}}async validateListing(t){try{return await this.getListing(t)}catch(r){throw console.error(`Error getting the listing with id ${t}`),r}}async mapListing(t){let r=p.UNSET;const a=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;switch(t.status){case 1:r=s.from(t.startTimestamp).gt(a)?p.Created:s.from(t.endTimestamp).lt(a)?p.Expired:p.Active;break;case 2:r=p.Completed;break;case 3:r=p.Cancelled;break}return{assetContractAddress:t.assetContract,currencyContractAddress:t.currency,pricePerToken:t.pricePerToken.toString(),currencyValuePerToken:await m(this.contractWrapper.getProvider(),t.currency,t.pricePerToken),id:t.listingId.toString(),tokenId:t.tokenId.toString(),quantity:t.quantity.toString(),startTimeInSeconds:s.from(t.startTimestamp).toNumber(),asset:await F(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),endTimeInSeconds:s.from(t.endTimestamp).toNumber(),creatorAddress:t.listingCreator,isReservedListing:t.reserved,status:r}}async isStillValidListing(t,r){if(!await J(this.contractWrapper.getProvider(),this.getAddress(),t.assetContractAddress,t.tokenId,t.creatorAddress))return{valid:!1,error:`Token '${t.tokenId}' from contract '${t.assetContractAddress}' is not approved for transfer`};const a=this.contractWrapper.getProvider(),n=new S(t.assetContractAddress,Q,a),c=await n.supportsInterface(X),o=await n.supportsInterface(Y);if(c){const h=(await new S(t.assetContractAddress,tt,a).ownerOf(t.tokenId)).toLowerCase()===t.creatorAddress.toLowerCase();return{valid:h,error:h?void 0:`Seller is not the owner of Token '${t.tokenId}' from contract '${t.assetContractAddress} anymore'`}}else if(o){const f=(await new S(t.assetContractAddress,rt,a).balanceOf(t.creatorAddress,t.tokenId)).gte(r||t.quantity);return{valid:f,error:f?void 0:`Seller does not have enough balance of Token '${t.tokenId}' from contract '${t.assetContractAddress} to fulfill the listing`}}else return{valid:!1,error:"Contract does not implement ERC 1155 or ERC 721."}}applyFilter(t,r){let e=[...t];return r&&(r.seller&&(e=e.filter(a=>{var n;return a.listingCreator.toString().toLowerCase()===((n=r==null?void 0:r.seller)==null?void 0:n.toString().toLowerCase())})),r.tokenContract&&(e=e.filter(a=>{var n;return a.assetContract.toString().toLowerCase()===((n=r==null?void 0:r.tokenContract)==null?void 0:n.toString().toLowerCase())})),r.tokenId!==void 0&&(e=e.filter(a=>{var n;return a.tokenId.toString()===((n=r==null?void 0:r.tokenId)==null?void 0:n.toString())}))),(r==null?void 0:r.count)&&r.count<e.length?e.slice(0,r.count):e}}const ot=v.object({assetContractAddress:w,tokenId:u,quantity:u.default(1),currencyContractAddress:w.default(I),minimumBidAmount:C,buyoutBidAmount:C,timeBufferInSeconds:u.default(900),bidBufferBps:u.default(500),startTimestamp:M.default(new Date),endTimestamp:O});class it{constructor(t,r){i(this,"featureName",z.name),i(this,"contractWrapper",void 0),i(this,"storage",void 0),i(this,"events",void 0),i(this,"interceptor",void 0),i(this,"encoder",void 0),i(this,"estimator",void 0),this.contractWrapper=t,this.storage=r,this.events=new k(this.contractWrapper),this.encoder=new W(this.contractWrapper),this.interceptor=new T(this.contractWrapper),this.estimator=new b(this.contractWrapper)}getAddress(){return this.contractWrapper.readContract.address}async getTotalCount(){return await this.contractWrapper.readContract.totalAuctions()}async getAll(t){const r=await this.getTotalCount();let e=s.from((t==null?void 0:t.start)||0).toNumber(),a=r.toNumber();if(a===0)throw new Error("No auctions exist on the contract.");let n=[];n=(await A(e,a,this.contractWrapper.readContract.getAllAuctions)).flat();const o=this.applyFilter(n,t);return await Promise.all(o.map(d=>this.mapAuction(d)))}async getAllValid(t){const r=await this.getTotalCount();let e=s.from((t==null?void 0:t.start)||0).toNumber(),a=r.toNumber();if(a===0)throw new Error("No auctions exist on the contract.");let n=[];n=(await A(e,a,this.contractWrapper.readContract.getAllValidAuctions)).flat();const o=this.applyFilter(n,t);return await Promise.all(o.map(d=>this.mapAuction(d)))}async getAuction(t){const r=await this.contractWrapper.readContract.getAuction(t);return await this.mapAuction(r)}async getWinningBid(t){await this.validateAuction(s.from(t));const r=await this.contractWrapper.readContract.getWinningBid(t);if(r._bidder!==V)return await this.mapBid(t.toString(),r._bidder,r._currency,r._bidAmount.toString())}async isWinningBid(t,r){return await this.contractWrapper.readContract.isNewWinningBid(t,r)}async getWinner(t){const r=await this.validateAuction(s.from(t)),e=await this.contractWrapper.readContract.getWinningBid(t),a=s.from(Math.floor(Date.now()/1e3)),n=s.from(r.endTimeInSeconds);if(a.gt(n)&&e._bidder!==V)return e._bidder;const o=(await this.contractWrapper.readContract.queryFilter(this.contractWrapper.readContract.filters.AuctionClosed())).find(d=>d.args.auctionId.eq(s.from(t)));if(!o)throw new Error(`Could not find auction with ID ${t} in closed auctions`);return o.args.winningBidder}async createAuction(t){const r=ot.parse(t);await y(this.contractWrapper,this.getAddress(),r.assetContractAddress,r.tokenId,await this.contractWrapper.getSignerAddress());const e=await g(this.contractWrapper.getProvider(),r.buyoutBidAmount,r.currencyContractAddress),a=await g(this.contractWrapper.getProvider(),r.minimumBidAmount,r.currencyContractAddress),c=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;r.startTimestamp.lt(c)&&(r.startTimestamp=s.from(c));const o=await this.contractWrapper.sendTransaction("createAuction",[{assetContract:r.assetContractAddress,tokenId:r.tokenId,quantity:r.quantity,currency:E(r.currencyContractAddress),minimumBidAmount:a,buyoutBidAmount:e,timeBufferInSeconds:r.timeBufferInSeconds,bidBufferBps:r.bidBufferBps,startTimestamp:r.startTimestamp,endTimestamp:r.endTimestamp}],{gasLimit:5e5});return{id:this.contractWrapper.parseLogs("NewAuction",o==null?void 0:o.logs)[0].args.auctionId,receipt:o}}async buyoutAuction(t){const r=await this.validateAuction(s.from(t)),e=await et(this.contractWrapper.getProvider(),r.currencyContractAddress);return this.makeBid(t,at(r.buyoutBidAmount,e.decimals))}async makeBid(t,r){const e=await this.validateAuction(s.from(t)),a=await g(this.contractWrapper.getProvider(),r,e.currencyContractAddress);if(a.eq(s.from(0)))throw new Error("Cannot make a bid with 0 value");if(s.from(e.buyoutBidAmount).gt(0)&&a.gt(e.buyoutBidAmount))throw new Error("Bid amount must be less than or equal to buyoutBidAmount");if(await this.getWinningBid(t)){const o=await this.isWinningBid(t,a);l(o,"Bid price is too low based on the current winning bid and the bid buffer")}else{const o=a,d=s.from(e.minimumBidAmount);l(o.gte(d),"Bid price is too low based on minimum bid amount")}const c=await this.contractWrapper.getCallOverrides()||{};return await N(this.contractWrapper,a,e.currencyContractAddress,c),{receipt:await this.contractWrapper.sendTransaction("bidInAuction",[t,a],c)}}async cancelAuction(t){if(await this.getWinningBid(t))throw new Error("Bids already made.");return{receipt:await this.contractWrapper.sendTransaction("cancelAuction",[t])}}async closeAuctionForBidder(t,r){r||(r=await this.contractWrapper.getSignerAddress());const e=await this.validateAuction(s.from(t));try{return{receipt:await this.contractWrapper.sendTransaction("collectAuctionTokens",[s.from(t)])}}catch(a){throw a.message.includes("Marketplace: auction still active.")?new P(t.toString(),e.endTimeInSeconds.toString()):a}}async closeAuctionForSeller(t){const r=await this.validateAuction(s.from(t));try{return{receipt:await this.contractWrapper.sendTransaction("collectAuctionPayout",[s.from(t)])}}catch(e){throw e.message.includes("Marketplace: auction still active.")?new P(t.toString(),r.endTimeInSeconds.toString()):e}}async executeSale(t){const r=await this.validateAuction(s.from(t));try{const e=await this.getWinningBid(t);l(e,"No winning bid found");const a=this.encoder.encode("collectAuctionPayout",[t]),n=this.encoder.encode("collectAuctionTokens",[t]);return await this.contractWrapper.multiCall([a,n])}catch(e){throw e.message.includes("Marketplace: auction still active.")?new P(t.toString(),r.endTimeInSeconds.toString()):e}}async getBidBufferBps(t){return(await this.getAuction(t)).bidBufferBps}async getMinimumNextBid(t){const[r,e,a]=await Promise.all([this.getBidBufferBps(t),this.getWinningBid(t),await this.validateAuction(s.from(t))]),n=e?s.from(e.bidAmount):s.from(a.minimumBidAmount),c=n.add(n.mul(r).div(1e4));return m(this.contractWrapper.getProvider(),a.currencyContractAddress,c)}async validateAuction(t){try{return await this.getAuction(t)}catch(r){throw console.error(`Error getting the auction with id ${t}`),r}}async mapAuction(t){let r=p.UNSET;const a=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;switch(t.status){case 1:r=s.from(t.startTimestamp).gt(a)?p.Created:s.from(t.endTimestamp).lt(a)?p.Expired:p.Active;break;case 2:r=p.Completed;break;case 3:r=p.Cancelled;break}return{id:t.auctionId.toString(),creatorAddress:t.auctionCreator,assetContractAddress:t.assetContract,tokenId:t.tokenId.toString(),quantity:t.quantity.toString(),currencyContractAddress:t.currency,minimumBidAmount:t.minimumBidAmount.toString(),minimumBidCurrencyValue:await m(this.contractWrapper.getProvider(),t.currency,t.minimumBidAmount),buyoutBidAmount:t.buyoutBidAmount.toString(),buyoutCurrencyValue:await m(this.contractWrapper.getProvider(),t.currency,t.buyoutBidAmount),timeBufferInSeconds:s.from(t.timeBufferInSeconds).toNumber(),bidBufferBps:s.from(t.bidBufferBps).toNumber(),startTimeInSeconds:s.from(t.startTimestamp).toNumber(),endTimeInSeconds:s.from(t.endTimestamp).toNumber(),asset:await F(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),status:r}}async mapBid(t,r,e,a){return{auctionId:t,bidderAddress:r,currencyContractAddress:e,bidAmount:a,bidAmountCurrencyValue:await m(this.contractWrapper.getProvider(),e,a)}}applyFilter(t,r){let e=[...t];return r&&(r.seller&&(e=e.filter(a=>{var n;return a.auctionCreator.toString().toLowerCase()===((n=r==null?void 0:r.seller)==null?void 0:n.toString().toLowerCase())})),r.tokenContract&&(e=e.filter(a=>{var n;return a.assetContract.toString().toLowerCase()===((n=r==null?void 0:r.tokenContract)==null?void 0:n.toString().toLowerCase())})),r.tokenId!==void 0&&(e=e.filter(a=>{var n;return a.tokenId.toString()===((n=r==null?void 0:r.tokenId)==null?void 0:n.toString())}))),(r==null?void 0:r.count)&&r.count<e.length?e.slice(0,r.count):e}}const ct=v.object({assetContractAddress:w,tokenId:u,quantity:u.default(1),currencyContractAddress:w.default(I),totalPrice:C,endTimestamp:O});class dt{constructor(t,r){i(this,"featureName",G.name),i(this,"contractWrapper",void 0),i(this,"storage",void 0),i(this,"events",void 0),i(this,"interceptor",void 0),i(this,"encoder",void 0),i(this,"estimator",void 0),this.contractWrapper=t,this.storage=r,this.events=new k(this.contractWrapper),this.encoder=new W(this.contractWrapper),this.interceptor=new T(this.contractWrapper),this.estimator=new b(this.contractWrapper)}getAddress(){return this.contractWrapper.readContract.address}async getTotalCount(){return await this.contractWrapper.readContract.totalOffers()}async getAll(t){const r=await this.getTotalCount();let e=s.from((t==null?void 0:t.start)||0).toNumber(),a=r.toNumber();if(a===0)throw new Error("No offers exist on the contract.");let n=[];n=(await A(e,a,this.contractWrapper.readContract.getAllOffers)).flat();const o=this.applyFilter(n,t);return await Promise.all(o.map(d=>this.mapOffer(d)))}async getAllValid(t){const r=await this.getTotalCount();let e=s.from((t==null?void 0:t.start)||0).toNumber(),a=r.toNumber();if(a===0)throw new Error("No offers exist on the contract.");let n=[];n=(await A(e,a,this.contractWrapper.readContract.getAllValidOffers)).flat();const o=this.applyFilter(n,t);return await Promise.all(o.map(d=>this.mapOffer(d)))}async getOffer(t){const r=await this.contractWrapper.readContract.getOffer(t);return await this.mapOffer(r)}async makeOffer(t){const r=ct.parse(t),e=await this.contractWrapper.getChainID(),a=q(r.currencyContractAddress)?x[e].wrapped.address:r.currencyContractAddress,n=await g(this.contractWrapper.getProvider(),r.totalPrice,a),c=await this.contractWrapper.getCallOverrides();await N(this.contractWrapper,n,a,c);const o=await this.contractWrapper.sendTransaction("makeOffer",[{assetContract:r.assetContractAddress,tokenId:r.tokenId,quantity:r.quantity,currency:a,totalPrice:n,expirationTimestamp:r.endTimestamp}],{gasLimit:5e5});return{id:this.contractWrapper.parseLogs("NewOffer",o==null?void 0:o.logs)[0].args.offerId,receipt:o}}async cancelOffer(t){return{receipt:await this.contractWrapper.sendTransaction("cancelOffer",[t])}}async acceptOffer(t){const r=await this.validateOffer(s.from(t)),{valid:e,error:a}=await this.isStillValidOffer(r);if(!e)throw new Error(`Offer ${t} is no longer valid. ${a}`);const n=await this.contractWrapper.getCallOverrides()||{};return await y(this.contractWrapper,this.getAddress(),r.assetContractAddress,r.tokenId,await this.contractWrapper.getSignerAddress()),{receipt:await this.contractWrapper.sendTransaction("acceptOffer",[t],n)}}async validateOffer(t){try{return await this.getOffer(t)}catch(r){throw console.error(`Error getting the offer with id ${t}`),r}}async mapOffer(t){let r=p.UNSET;const a=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;switch(t.status){case 1:r=s.from(t.expirationTimestamp).lt(a)?p.Expired:p.Active;break;case 2:r=p.Completed;break;case 3:r=p.Cancelled;break}return{id:t.offerId.toString(),offerorAddress:t.offeror,assetContractAddress:t.assetContract,currencyContractAddress:t.currency,tokenId:t.tokenId.toString(),quantity:t.quantity.toString(),totalPrice:t.totalPrice.toString(),currencyValue:await m(this.contractWrapper.getProvider(),t.currency,t.totalPrice),asset:await F(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),endTimeInSeconds:s.from(t.expirationTimestamp).toNumber(),status:r}}async isStillValidOffer(t){if(s.from(Math.floor(Date.now()/1e3)).gt(t.endTimeInSeconds))return{valid:!1,error:`Offer with ID ${t.id} has expired`};const e=await this.contractWrapper.getChainID(),a=q(t.currencyContractAddress)?x[e].wrapped.address:t.currencyContractAddress,n=this.contractWrapper.getProvider(),c=new _(n,a,nt,{});return(await c.readContract.balanceOf(t.offerorAddress)).lt(t.totalPrice)?{valid:!1,error:`Offeror ${t.offerorAddress} doesn't have enough balance of token ${a}`}:(await c.readContract.allowance(t.offerorAddress,this.getAddress())).lt(t.totalPrice)?{valid:!1,error:`Offeror ${t.offerorAddress} hasn't approved enough amount of token ${a}`}:{valid:!0,error:""}}applyFilter(t,r){let e=[...t];return r&&(r.offeror&&(e=e.filter(a=>{var n;return a.offeror.toString().toLowerCase()===((n=r==null?void 0:r.offeror)==null?void 0:n.toString().toLowerCase())})),r.tokenContract&&(e=e.filter(a=>{var n;return a.assetContract.toString().toLowerCase()===((n=r==null?void 0:r.tokenContract)==null?void 0:n.toString().toLowerCase())})),r.tokenId!==void 0&&(e=e.filter(a=>{var n;return a.tokenId.toString()===((n=r==null?void 0:r.tokenId)==null?void 0:n.toString())}))),(r==null?void 0:r.count)&&r.count<e.length?e.slice(0,r.count):e}}class ${get directListings(){return B(this.detectDirectListings(),U)}get englishAuctions(){return B(this.detectEnglishAuctions(),z)}get offers(){return B(this.detectOffers(),G)}get chainId(){return this._chainId}constructor(t,r,e){let a=arguments.length>3&&arguments[3]!==void 0?arguments[3]:{},n=arguments.length>4?arguments[4]:void 0,c=arguments.length>5?arguments[5]:void 0,o=arguments.length>6&&arguments[6]!==void 0?arguments[6]:new _(t,r,n,a);i(this,"abi",void 0),i(this,"contractWrapper",void 0),i(this,"storage",void 0),i(this,"encoder",void 0),i(this,"events",void 0),i(this,"estimator",void 0),i(this,"platformFees",void 0),i(this,"metadata",void 0),i(this,"roles",void 0),i(this,"interceptor",void 0),i(this,"_chainId",void 0),this._chainId=c,this.abi=n,this.contractWrapper=o,this.storage=e,this.metadata=new j(this.contractWrapper,H,this.storage),this.roles=new K(this.contractWrapper,$.contractRoles),this.encoder=new W(this.contractWrapper),this.estimator=new b(this.contractWrapper),this.events=new k(this.contractWrapper),this.platformFees=new Z(this.contractWrapper),this.interceptor=new T(this.contractWrapper)}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.readContract.address}async call(t){for(var r=arguments.length,e=new Array(r>1?r-1:0),a=1;a<r;a++)e[a-1]=arguments[a];return this.contractWrapper.call(t,...e)}detectDirectListings(){if(L(this.contractWrapper,"DirectListings"))return new st(this.contractWrapper,this.storage)}detectEnglishAuctions(){if(L(this.contractWrapper,"EnglishAuctions"))return new it(this.contractWrapper,this.storage)}detectOffers(){if(L(this.contractWrapper,"Offers"))return new dt(this.contractWrapper,this.storage)}}i($,"contractRoles",["admin","lister","asset"]);export{$ as MarketplaceV3};
